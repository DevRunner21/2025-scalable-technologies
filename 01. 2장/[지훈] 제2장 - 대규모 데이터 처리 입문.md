# 대규모 데이터 처리의 어려운 점

<aside>
💡 메모리 내에서 계산할 수 없다.
</aside>

- 데이터가 너무 많아서 메모리 내에서 계산할 수 없게 되면 디스크에 있는 데이터를 검색하게 된다.
- 하지만 **디스크는 메모리에 비해 상당히 느리며, I/O에 시간이 걸린다**.

## 디스크는 왜 늦을까? ( 메모리  vs 디스크 )

![Image](https://github.com/user-attachments/assets/ec7d3427-5612-4086-8f1e-24d15f828623)

### **탐색 속도의 차이**

- 디스크는 헤드의 이동과 원반의 회전이라는 두 가지 물리적인 동작을 수반하고 있다.
  이러한 물리적인 구조가 탐색 속도에 영향을 준다.
- 메모리는 전기적인 부품으로 물리적 구조는 탐색 속도와 그다지 관계없다.
    - 데이터가 메모리상에 있다면 탐색할 때 물리적인 동작 없이 실제 데이터 탐색 시의 오버헤드가 거의 없으므로 빠른 것이다.

### **OS 레벨에서의 탐색 속도 개선 전략**

디스크는 느리지만 OS는 이러한 점을 어느 정도 커버하는 작용을 한다.

> OS는 연속된 데이터를 같은 위치에 쌓는 전략을 취한다.
>
> - 데이터를 읽을 때 1바이트씩 읽는 것이 아니라 4KB 정도를 한꺼번에 읽도록 한다.
- 이렇게 해서 비슷한 데이터를 비슷한 곳에 두어 1번의 디스크 회전으로 읽는 데이터의 수를 많게 한다.

  → 그 결과 **디스크의 회전 횟수를 최소화할 수 있게 한다.**


### **전송 속도의 차이**

- 전송 속도?

  > 탐색을 통해 찾은 데이터를 디스크에서 메모리로 보내거나 메모리에서 CPU로 보내는 등
  컴퓨터 내부에서 전송하기 위한 속도를 의미한다.

- 메모리나 디스크 모두 CPU와 버스로 연결되어 있다. 이 버스의 속도에서도 상당한 차이가 있다.
- 메모리와 CPU는 상당히 빠른 버스로 연결되어 있는 반면
  디스크는 메모리나 CPU에 비해 많이 느리다.

# 규모정의 요소

처리하는 데이터가 커질 수록 메모리에서만 데이터를 처리할 수 없게 되고
속도가 느린 디스크를 더 많이 사용하게 되면서 전체적인 성능 저하가 발생한다.

이런 점은 시스템 전체의 확장 전략에 어떤 영향을 주게 될까?

## 규모조정(Scaling), 확장성 = 시스템 확장 전략

![Image](https://github.com/user-attachments/assets/d683f322-3c09-44bf-8869-4b6c6afdb72f)

웹 서비스에서는 고가의 빠른 하드웨어를 사서 성능을 높이는 **스케일업(Scale-Up)** 전략보다 
**저가이면서 일반적인 성능의 하드웨어를 많이 나열해서 시스템 전체 성능을 올리는 스케일아웃(Scale-Out)** 전략**이 주류이다.**

### 스케일아웃(Scale-Out)이 더 나은 이유?

- 웹 서비스에 적합한 형태이고 비용이 저렴하다
- 시스템 구성에 유연성이 있다.
    - 부하가 적을 때는 서버를 줄이고
      부하가 높을 때는 서버를 늘리는 식으로 유연하게 대처가 용이하다.

## 규모조정의 요소

스케일 아웃을 통해서 CPU 부하의 확장성을 확보하기는 쉽다.
하지만 DB 측면에서 발생하는 I/O 부하는 해결하지 못한다.

## 웹 애플리케이션과 부하의 관계

![Image](https://github.com/user-attachments/assets/2a3224c3-503e-4319-9a71-b6268676dede)

웹 애플리케이션은 기본적으로 아래 3단계 구조를 갖는다,

- 프록시
- AP 서버
- DB

이 구조에서 부하가 발생하는 지점은 아래와 같다.

- AP 서버에서 작업을 처리 할 때 → CPU 부하 발생
- DB에서 데이터를 가져올 때 → I/O 부하 발생

각각의 관점에서 발생한 부하를 분산하기 위해 AP서버, DB를 확장(Scale-Out)해 볼 수 있다.

### **AP 서버의 관점**

AP 서버는 CPU 부하만 걸리므로 분산이 간단하다.

- 그 이유는 기본적으로 데이터를 분산해서 갖고 있는 것이 아니므로
  동일한 호스트가 동일하게 작업을 처리하기만 하면 분산할 수 있다. ****

**→ 따라서 앞단에 “로드밸런서”를 두고 서버 대수를 늘리기만 하면 간단히 확장해갈 수 있다.**

### **DB의 관점**

DB에는 I/O 부하가 발생하지만 이를 분산하는데에는 어려움이 있다.

- 쓰기 작업이 발생하였을 때 데이터를 어떻게 동기화할 것인가라는 문제가 생긴다.

## DB 확장성 확보의 어려움

DB 확장성을 확보하는 것은 상당히 어렵다.

- 일단 I/O 부하를 분산하기 위해 DB를 늘릴 경우 위에서 언급한 DB 간의 동기화 문제도 있고
- 서버를 늘릴 경우 DB로 요청되는 부하가 증가하게 되고 많은 디스크 I/O가 발생하게 된다.

  → 안그래도 느린 디스크 I/O가 많아질 경우 서버가 금새 느려지는 문제가 있다.

- 게다가 데이터가 커지면 커질수록 메모리에서 처리 못하고 디스크상에서 처리할 수밖에 없는 요건이 늘어난다.

# 대규모 데이터를 다루기 위한 기초지식

대규모 데이터는 메모리에서 처리하기 어렵고 디스크는 느리다.
또한 분산하기도 곤란하다.

이 문제를 어떻게 해결할 수 있을까?

아래 두가지 관점으로 대규모 데이터를 다루는 방법을 알아보자

- 프로그램 작성할 때의 관점
- 프로그램 개발의 근간이 되는 기초라는 점에서 전제로서 알아두었으면 하는 것

## 대규모 데이터를 다루는 요령 ( 프로그램 작성할 때의 관점 )

### 어떻게 하면 메모리에서 처리를 마칠 수 있을까?

메모리에서 처리를 마쳐야 하는 이유는 앞서 설명한 대로 디스크 seek 횟수가 확장성, 성능에 크게 영향을 주기 때문이다.  
디스크 seek 횟수를 최소화한다는 의미로 메모리를 활용하고자 한다.  
또한 국소성을 활용한 분산을 실현할 수 있다. ( 이에 대한건 나중에 설명 )

### 데이터량 증가에 강한 알고리즘을 사용하는 것

레코드 1,000만 건이 있을 때 단순히 선형탐색으로 하면 1,000만 번 계산을 수행해야 하는데
Log Order인 알고리즘을 적용하면 수십 번 만에 마칠 수 있다는 기본적인 예가 있다.
이렇게 알고리즘의 기초적인 부분을 제대로 활용하자는 것이다.

### **데이터 압축이나 검색기술과 같은 테크닉이 활용될 수 있는 국면이 있다.**

압축해서 데이터량을 줄일 수 있다면 읽어내는 seek 횟수도 적어지게 되므로
디스크 읽는 횟수를 최소화할 수 있다는 것이다.
또한 메모리에 캐싱하기 쉬워진다.

- 데이터가 크면 메모리에서 넘치거나 디스크에 저장해도 읽어내기에 시간이 걸리므로 압축이 중요해진다.

## 대규모 데이터를 다루기 전 3대 전제 지식

- OS 캐시
- 분산을 고려한 RDBMS 운용
- 대규모 환경에서 알고리즘과 데이터 구조